// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4415.ProtoBotProtoCode.subsystems;

import org.usfirst.frc4415.ProtoBotProtoCode.Robot;
import org.usfirst.frc4415.ProtoBotProtoCode.RobotMap;
import org.usfirst.frc4415.ProtoBotProtoCode.commands.*;
import com.ctre.CANTalon;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	AHRS ahrs;
    boolean changeDrive = true;
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon cANTalon1 = RobotMap.driveTrainCANTalon1;
    private final CANTalon cANTalon2 = RobotMap.driveTrainCANTalon2;
    private final CANTalon cANTalon3 = RobotMap.driveTrainCANTalon3;
    private final CANTalon cANTalon4 = RobotMap.driveTrainCANTalon4;
    private final RobotDrive robotDrive4 = RobotMap.driveTrainRobotDrive4;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ProtoDriveTrain());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void protoMecanumDrive(){
    	robotDrive4.mecanumDrive_Cartesian(Robot.oi.getProtoJoystick().getX(), Robot.oi.getProtoJoystick().getY(), Robot.oi.getProtoJoystick().getZ(), 0);
  //  	Timer.delay(0.005);	// wait 5ms to avoid hogging CPU cycles
    	
    }
    
    public void tryDrive(){
    	if (Robot.oi.getProtoJoystick().getRawButton(1)) {
            ahrs.reset();
        }
        try {
            /* Use the joystick X axis for lateral movement,            */
            /* Y axis for forward movement, and Z axis for rotation.    */
            /* Use navX MXP yaw angle to define Field-centric transform */
            
        	
        		robotDrive4.mecanumDrive_Cartesian(Robot.oi.getProtoJoystick().getX(), Robot.oi.getProtoJoystick().getY(), 
            		Robot.oi.getProtoJoystick().getTwist(), ahrs.getAngle());
        } catch( RuntimeException ex ) {
            DriverStation.reportError("Error communicating with drive system:  " + ex.getMessage(), true);
        }
        Timer.delay(0.005);		// wait for a motor update time
        
    }
    public void gyroMecanumDrive(){
    	
            if (Robot.oi.getProtoJoystick().getRawButton(1)) {
                ahrs.reset();
            }
            try {
                /* Use the joystick X axis for lateral movement,            */
                /* Y axis for forward movement, and Z axis for rotation.    */
                /* Use navX MXP yaw angle to define Field-centric transform */
                
            	if(changeDrive==false){
            		robotDrive4.mecanumDrive_Cartesian(Robot.oi.getProtoJoystick().getX(), Robot.oi.getProtoJoystick().getY(), 
                		Robot.oi.getProtoJoystick().getTwist(), ahrs.getAngle());
            	} else{
            		robotDrive4.mecanumDrive_Cartesian(Robot.oi.getProtoJoystick().getX(), Robot.oi.getProtoJoystick().getY(), 
                    		Robot.oi.getProtoJoystick().getTwist(), 0);
                	}
            
            } catch( RuntimeException ex ) {
                DriverStation.reportError("Error communicating with drive system:  " + ex.getMessage(), true);
            }
            Timer.delay(0.005);		// wait for a motor update time
        }
    
    public void changeProtoMecanumDriveCode(){
    	changeDrive = true;
    }
    
    public void changeGyroMecanumDriveCode(){
    	changeDrive = false;
    }
    
    public boolean getChangeDrive(){
    	return changeDrive;
    }
    
    public void protoMotorsSlowForward(){
    	cANTalon1.set(.25);
        cANTalon2.set(.25);
        cANTalon3.set(.25);
        cANTalon4.set(.25);
    }
    
    public void protoMotorsOff(){
    	cANTalon1.set(0);
        cANTalon2.set(0);
        cANTalon3.set(0);
        cANTalon4.set(0);
    }
    
    public void changeDirection(){
    	RobotMap.driveTrainRobotDrive4.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
        RobotMap.driveTrainRobotDrive4.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        RobotMap.driveTrainRobotDrive4.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        RobotMap.driveTrainRobotDrive4.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
    }
    
    
    
    
}











